// การส่งผ่านข้อมูลที่ยืมมา
// กฎที่ใช้กับการอ้างอิงใน Rust อาจจะสรุปออกมาได้ดังนี้:

// Rust ยอมให้มีการอ้างอิงถึงของที่เปลี่ยนแปลงค่าได้แค่ตัวเดียว หรือ หลายตัวก็ได้แต่ต้องเป็นแบบเปลี่ยนแปลงค่าไม่ได้ แต่ทำทั้งสองอย่างพร้อมกันไม่ได้
// ตัวที่อ้างอิงถึงตัวอื่น จะต้องไม่มี lifetimes นานกว่าเจ้าของ
// สิ่งนี้ไม่มีแนวโน้มที่จะเป็นปัญหาเมื่อส่งต่อการอ้างอิงถึงฟังก์ชัน

// รายละเอียดหน่วยความจำ:

// กฎข้อแรกของ การอ้างอิง ใช้ป้องกันการแย่งข้อมูลกัน แล้วการแย่งข้อมูลกันคืออะไร? การแย่งข้อมูลกัน เกิดขึ้น ในขณะมีการอ่านข้อมูล ข้อมูลที่ได้อาจจะไม่ตรงกับปัจจุบัน หากมีการเขียนข้อมูลเกิดขึ้นในเวลาเดียวกัน สิ่งนี้เกิดขึ้นบ่อยครั้งในการเขียนโปรแกรมแบบมัลติเธรด
// กฎข้อที่สอง ใช้ป้องกันการเกิดตัวอ้างอิง ที่อ้างถึงของที่ไม่มีอยู่จริง (เรียกว่า dangling pointers ในภาษา C)

struct Foo {
    x: i32,
}

fn do_something(f: &mut Foo) {
    f.x += 1;
    // mutable reference f is dropped here
}

fn main() {
    let mut foo = Foo { x: 42 };
    do_something(&mut foo);
    println!("{}", foo.x);
    // because all mutable references are dropped within
    // the function do_something, we can create another.
    do_something(&mut foo);
    println!("{}", foo.x);
    // foo is dropped here
}
